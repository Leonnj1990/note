# 分布式数据库原理

---

## 事物简介

### 事物就是锁和并发
* 优势: 容易理解
* 劣势: 性能较低

### 单个事物单元: ACID保证事物的完整性

* 原子性
* 一致性
	* A给B100元块, 要么A的钱数没有变, B的钱数也没有变, 要么A的钱数减少100, B的钱数加100元, 而**不会有任何中间状态**
* 隔离性
* 持久性

#### 这些也是单个事物单元
* 建立索引
* 从数据库读取一行记录
* 向数据库中写入一行记录, 同时更新这行记录的所有索引
* 删除整张表

### 一组事物单元

#### 事物单元之间的关系: 
* 读写  
* 写读  
* 读读 
* 写写

#### 排队法: 序列化
序列化读写, 发生冲突的话, 可使用串行

* 优势: 不需要冲突控制
* 劣势: 慢速设备, 性能太低

#### 排他锁
针对同一个单元(可共享数据)的访问进行控制, 对于没有冲突的事物单元, 可是使用并行

#### 读写锁
针对读读场景可以做优化, 写和读完全分离, 只能对于读读并行
**先读后写, 先写后读都只能串行**

### MVCC
能够做到写不阻塞读, 本质就是 **copy on write**, **写串行, 读并行**

## 事物处理常见问题

### 多个事物, 谁先谁后(在MVCC场景下)
一个读请求应该读哪一个写之后的数据？
	
	逻辑时间戳:保证先后顺序, 不是真正意义上的时间的描述
	SCN(Oracle)
	Trx_id(Innodb)
	
	物理时间戳: 时间

### 故障恢复: 事物回滚

#### 可能的错误情况
* 业务不匹配
* 系统崩溃

### 死锁与死锁检测

#### 死锁产生的原因
* 两个线程
* 不同方向
* 相同资源
	* 事物单元1: A给B转账
	* 事物单元2: B给A转账

#### 死锁解决方案
* 尽可能不死锁
* 碰撞检测: 终止一边
* 等锁超时

## 深入单机事物

### 事物的ACID

* 原子性(Atom): 记录undo日志回滚到之前的版本
	* 一个事物要么同时成功, 要么同时失败
* 一致性(Consistency): 保证能看到系统内的所有更改
* 隔离性(Isolation): 以性能为理由, 对一致性的破坏
	* 隔离级别: SQL 92标准定义的隔离性
		* 1. 序列化读
	    	* 排他锁
	 	* 读写锁
	   		* 2. 可重复读   
	   			* 读锁不能被写锁升级
	   			* 读读可并行
	   		* 3. 读已提交(read commited)
	   			* 读读并行, 读写并行(写读还不能)
	   		* 4. 读未提交 (read uncommited)
	   			* 只加写锁, 读不加锁: 可能读到写过程中的数据
	   				* 读读并行
	   				* 读写并行
	   				* 写读并行 
	   				* 写写串行
* 持久性(Durability):





